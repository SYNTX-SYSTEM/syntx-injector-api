"""
from pathlib import Path
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                              â•‘
â•‘    ğŸŒŠâš¡ğŸ’ SYNTX FIELD RESONANCE SERVICE ğŸ’âš¡ğŸŒŠ                               â•‘
â•‘                                                                              â•‘
â•‘    Nicht "API Server" - RESONANZ-ORCHESTRATOR.                               â•‘
â•‘                                                                              â•‘
â•‘    Hier flieÃŸen alle StrÃ¶me zusammen:                                        â•‘
â•‘      - Wrapper (WIE denkt das Modell)                                        â•‘
â•‘      - Formate (WAS kommt raus)  â† NEU!                                      â•‘
â•‘      - User Input (Die Frage)                                                â•‘
â•‘      - Model Response (Die Antwort)                                          â•‘
â•‘                                                                              â•‘
â•‘    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•      â•‘
â•‘                                                                              â•‘
â•‘    "Nicht mehr Token. Nicht mehr Drift.                                      â•‘
â•‘     Nur Felder. Nur StrÃ¶me. Nur Resonanz."                                  â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
from fastapi import FastAPI, HTTPException
from typing import Optional
from pathlib import Path
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import time
import json

from .config import settings
from .models import ChatRequest, ChatResponse
from .streams import (
    load_wrapper_stream,
    wrap_input_stream,
    forward_stream,
    generate_request_id,
    get_timestamp,
    build_format_section,  # NEU!
    FORMAT_LOADER_AVAILABLE  # NEU!
)

# ğŸ¨ STYLE ALCHEMIST - Post-Processing Magic
try:
    from .styles import apply_style_magic, get_tone_injection, list_available_styles
    STYLE_ALCHEMIST_AVAILABLE = True
    print("ğŸ¨ STYLE ALCHEMIST AKTIVIERT!")
except ImportError:
    STYLE_ALCHEMIST_AVAILABLE = False


# Import resonance routers
from .resonance.wrappers import router as wrappers_router
from .resonance.streams import router as streams_router
from .resonance.stats import router as stats_router
from .resonance.config import router as config_router
from .resonance.formats import router as formats_router
from .resonance.styles import router as styles_router
# ğŸ†• NEUE STRÃ–ME - Diff, Sessions, Alchemy
from .resonance.diff import router as diff_router
from .resonance.sessions import router as sessions_router
from .resonance.alchemy import router as alchemy_router


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ“ STAGE LOGGING - Feld-Flow Dokumentation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def log_stage(stage: str, data: dict):
    """
    ğŸ“ STAGE LOGGING
    
    Nicht "Logging" - FELD-FLOW DOKUMENTATION.
    
    Jede Stage des Feld-Flows wird dokumentiert:
      1_INCOMING       â†’ Request kommt an
      2_WRAPPERS_LOADED â†’ Wrapper aktiviert
      2.5_FORMAT_LOADED â†’ Format injiziert (NEU!)
      3_FIELD_CALIBRATED â†’ Alles zusammengefÃ¼hrt
      4_BACKEND_FORWARD  â†’ Ab zum Modell
      5_RESPONSE        â†’ Antwort da
    """
    print("\n" + "ğŸŒŠ" * 40)
    print(f"ğŸ“ STAGE: {stage}")
    print("â”€" * 80)
    for key, value in data.items():
        if isinstance(value, str) and len(value) > 500:
            print(f"{key}: {value[:500]}... ({len(value)} chars total)")
        else:
            print(f"{key}: {value}")
    print("ğŸŒŠ" * 40 + "\n")
    
    # Persist to file
    settings.log_dir.mkdir(parents=True, exist_ok=True)
    log_file = settings.log_dir / "field_flow.jsonl"
    with open(log_file, 'a', encoding='utf-8') as f:
        log_entry = {"stage": stage, "timestamp": get_timestamp(), **data}
        f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
    
    # Response-specific logging
    if stage == "5_RESPONSE":
        wrapper_log = settings.log_dir / "wrapper_requests.jsonl"
        with open(wrapper_log, 'a', encoding='utf-8') as f:
            f.write(json.dumps(data, ensure_ascii=False) + '\n')


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸš€ APP LIFECYCLE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    ğŸš€ APP STARTUP
    
    Das Resonanz-Feld Ã¶ffnet sich.
    """
    print("=" * 80)
    print("ğŸŒŠâš¡ğŸ’ SYNTX FIELD RESONANCE SERVICE ğŸ’âš¡ğŸŒŠ")
    print("=" * 80)
    print(f"Backend:    {settings.backend_url}")
    print(f"Model:      {settings.model_name}")
    print(f"Wrappers:   {settings.wrapper_dir}")
    print(f"Formats:    /opt/syntx-config/formats/")
    print(f"Logs:       {settings.log_dir}")
    print(f"Format Loader: {'ğŸ”¥ AKTIV' if FORMAT_LOADER_AVAILABLE else 'âŒ NICHT VERFÃœGBAR'}")
    print("=" * 80)
    print("Endpoints:")
    print("  /resonanz/chat     â†’ Chat mit Wrapper + Format")
    print("  /resonanz/wrappers â†’ Wrapper Management")
    print("  /resonanz/formats  â†’ Format Info (NEU!)")
    print("=" * 80)
    yield
    print("ğŸŒŠ Resonanz-Feld schlieÃŸt sich...")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ—ï¸ APP INITIALIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

app = FastAPI(
    title="ğŸŒŠ SYNTX Field Resonance",
    description="Nicht API - RESONANZ-ORCHESTRATOR. Wrapper (WIE) + Format (WAS) = Kalibrierte Antworten.",
    version="2.1.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include resonance routers
app.include_router(wrappers_router)
app.include_router(streams_router)
app.include_router(stats_router)
app.include_router(config_router)
app.include_router(formats_router)
app.include_router(styles_router)
# ğŸ†• NEUE STRÃ–ME
app.include_router(diff_router)
app.include_router(sessions_router)
app.include_router(alchemy_router)
    
    if log_file.exists():
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                for line in reversed(lines[-10:]):
                    entry = json.loads(line)
                    if entry.get("stage") == "5_RESPONSE":
                        last_response = {
                            "response": entry.get("response", "")[:200] + "...",
                            "latency_ms": entry.get("latency_ms"),
                            "timestamp": entry.get("timestamp"),
                            "format": entry.get("format")  # NEU!
                        }
                        break
        except:
            pass
    
    return {
        "status": "ğŸŸ¢ RESONANZ AKTIV",
        "service": "syntx-field-resonance",
        "version": "2.1.0",
        "format_loader": "ğŸ”¥ AKTIV" if FORMAT_LOADER_AVAILABLE else "âŒ NICHT VERFÃœGBAR",
        "last_response": last_response
    }


@app.get("/api/chat/health")
async def chat_health():
    """Health check at /api/chat/health for compatibility"""
    return await health()


@app.get("/resonanz/health")
async def resonance_health():
    """Health check at /resonanz/health"""
    return await health()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ“‹ FORMAT ENDPOINTS (NEU!)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.get("/resonanz/formats")
async def list_formats():
    """
    ğŸ“‹ VERFÃœGBARE FORMATE LISTEN
    
    Zeigt alle Format-Definitionen die genutzt werden kÃ¶nnen.
    """
    if not FORMAT_LOADER_AVAILABLE:
        return {
            "status": "âŒ FORMAT_LOADER_NICHT_VERFÃœGBAR",
            "formats": [],
            "message": "Format Loader konnte nicht geladen werden"
        }
    
    from .formats import list_formats as _list_formats, load_format
    
    format_names = _list_formats()
    formats = []
    
    for name in format_names:
        fmt = load_format(name)
        if fmt:
            desc = fmt.get("description", {})
            formats.append({
                "name": name,
                "fields_count": len(fmt.get("fields", [])),
                "description": desc.get("de", desc) if isinstance(desc, dict) else desc,
                "languages": fmt.get("languages", ["de"])
            })
    
    return {
        "status": "ğŸ”¥ FORMATE GELADEN",
        "count": len(formats),
        "formats": formats
    }




# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ¨ STYLE ALCHEMY ENDPOINTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.get("/resonanz/styles")
async def list_styles():
    """
    ğŸ¨ ALLE STYLES IM GRIMOIRE
    
    Zeigt verfÃ¼gbare Style-Alchemien.
    """
    if not STYLE_ALCHEMIST_AVAILABLE:
        return {"status": "âŒ STYLE_ALCHEMIST_NICHT_VERFÃœGBAR", "styles": []}
    
    from .styles import list_available_styles, get_style_info
    
    style_names = list_available_styles()
    styles = []
    
    for name in style_names:
        info = get_style_info(name)
        if info:
            styles.append(info)
    
    return {
        "status": "ğŸ¨ GRIMOIRE GEÃ–FFNET",
        "count": len(styles),
        "styles": styles
    }


@app.get("/resonanz/styles/{style_name}")
async def get_style_details(style_name: str):
    """
    ğŸ”® STYLE DETAILS
    
    Zeigt alle Transmutationen eines Styles.
    """
    if not STYLE_ALCHEMIST_AVAILABLE:
        raise HTTPException(status_code=503, detail="Style Alchemist nicht verfÃ¼gbar")
    
    from .styles import summon_style
    
    style = summon_style(style_name)
    if not style:
        raise HTTPException(status_code=404, detail=f"Style '{style_name}' nicht im Grimoire")
    
    return {
        "status": "ğŸ”® STYLE BESCHWOREN",
        "style": {
            "name": style_name,
            "vibe": style.get("vibe", ""),
            "description": style.get("description", ""),
            "word_alchemy": style.get("word_alchemy", {}),
            "forbidden_words": style.get("forbidden_words", []),
            "has_tone_injection": bool(style.get("tone_injection")),
            "has_suffix": bool(style.get("suffix"))
        }
    }


@app.get("/resonanz/formats/{format_name}")
async def get_format_info(format_name: str, language: str = "de"):
    """
    ğŸ“„ FORMAT DETAILS
    
    Zeigt alle Felder eines Formats.
    """
    if not FORMAT_LOADER_AVAILABLE:
        raise HTTPException(status_code=503, detail="Format Loader nicht verfÃ¼gbar")
    
    from .formats import load_format, get_format_fields
    
    fmt = load_format(format_name)
    if not fmt:
        raise HTTPException(status_code=404, detail=f"Format '{format_name}' nicht gefunden")
    
    fields = get_format_fields(format_name, language)
    
    return {
        "status": "ğŸ”¥ FORMAT GELADEN",
        "format": {
            "name": format_name,
            "description": fmt.get("description", {}),
            "languages": fmt.get("languages", ["de"]),
            "fields": fields
        }
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ’¬ CHAT ENDPOINT - DAS HERZSTÃœCK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.post("/api/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """
    ğŸ’¬ CHAT - Das HerzstÃ¼ck des Systems
    
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                                           â•‘
    â•‘   ZWEI DIMENSIONEN:                                                       â•‘
    â•‘                                                                           â•‘
    â•‘   mode   = WIE denkt das Modell? (Wrapper)                               â•‘
    â•‘            â†’ Stil, TonalitÃ¤t, PersÃ¶nlichkeit                             â•‘
    â•‘                                                                           â•‘
    â•‘   format = WAS kommt raus? (Format)                                       â•‘
    â•‘            â†’ Felder, Struktur, Analyse-Schema                            â•‘
    â•‘                                                                           â•‘
    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
    â•‘                                                                           â•‘
    â•‘   BEISPIEL:                                                               â•‘
    â•‘                                                                           â•‘
    â•‘   POST /api/chat                                                          â•‘
    â•‘   {                                                                       â•‘
    â•‘       "prompt": "Analysiere das Internet",                                â•‘
    â•‘       "mode": "syntex_wrapper_sigma",    â† WIE (systemisch)              â•‘
    â•‘       "format": "syntex_system"          â† WAS (3 Felder)                â•‘
    â•‘   }                                                                       â•‘
    â•‘                                                                           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """
    request_id = generate_request_id()
    start_time = time.time()
    field_flow = []
    format_info = {}
    
    try:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        #  STAGE 1: INCOMING
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        stage_1_data = {
            "request_id": request_id,
            "prompt": request.prompt,
            "mode": request.mode,
            "format": request.format,  # NEU!
            "language": request.language,  # NEU!
            "include_init": request.include_init
        }
        log_stage("1_INCOMING", stage_1_data)
        field_flow.append({
            "stage": "1_INCOMING",
            "timestamp": get_timestamp(),
            "data": stage_1_data
        })
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        #  STAGE 2: LOAD WRAPPERS (WIE)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        wrapper_text, wrapper_chain = await load_wrapper_stream(
            request.mode,
            request.include_init,
            request.include_terminology
        )
        stage_2_data = {
            "request_id": request_id,
            "chain": wrapper_chain,
            "wrapper_preview": wrapper_text[:300] + "..." if len(wrapper_text) > 300 else wrapper_text
        }
        log_stage("2_WRAPPERS_LOADED", stage_2_data)
        field_flow.append({
            "stage": "2_WRAPPERS_LOADED",
            "timestamp": get_timestamp(),
            "data": {"chain": wrapper_chain}
        })
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        #  STAGE 2.5: LOAD FORMAT (WAS) - NEU!
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        format_section = ""
        if request.format:
            format_section, format_info = build_format_section(
                request.format, 
                request.language
            )
            stage_25_data = {
                "request_id": request_id,
                "format": request.format,
                "language": request.language,
                "format_info": format_info,
                "format_section_preview": format_section[:500] + "..." if len(format_section) > 500 else format_section
            }
            log_stage("2.5_FORMAT_LOADED", stage_25_data)
            field_flow.append({
                "stage": "2.5_FORMAT_LOADED",
                "timestamp": get_timestamp(),
                "data": format_info
            })
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        #  STAGE 3: CALIBRATE FIELD (Alles zusammen)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        wrapped_prompt = wrap_input_stream(
            wrapper_text, 
            request.prompt,
            format_section  # NEU!
        )
        stage_3_data = {
            "request_id": request_id,
            "calibrated_field_preview": wrapped_prompt[:800] + "..." if len(wrapped_prompt) > 800 else wrapped_prompt,
            "total_length": len(wrapped_prompt)
        }
        log_stage("3_FIELD_CALIBRATED", stage_3_data)
        field_flow.append({
            "stage": "3_FIELD_CALIBRATED",
            "timestamp": get_timestamp(),
            "data": {"total_length": len(wrapped_prompt)}
        })
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        #  STAGE 4: BACKEND FORWARD
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        backend_params = {
            "max_new_tokens": request.max_new_tokens,
            "temperature": request.temperature,
            "top_p": request.top_p,
            "do_sample": request.do_sample
        }
        stage_4_data = {
            "request_id": request_id,
            "backend_url": settings.backend_url,
            "model": settings.model_name,
            "params": backend_params
        }
        log_stage("4_BACKEND_FORWARD", stage_4_data)
        field_flow.append({
            "stage": "4_BACKEND_FORWARD",
            "timestamp": get_timestamp(),
            "data": {"backend": settings.backend_url, "model": settings.model_name}
        })
        
        # ğŸš€ FORWARD TO MODEL!
        response_text = await forward_stream(wrapped_prompt, backend_params)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        #  STAGE 5: RESPONSE
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        latency_ms = int((time.time() - start_time) * 1000)
        stage_5_data = {
            "request_id": request_id,
            "response": response_text,
            "latency_ms": latency_ms,
            "wrapper_chain": wrapper_chain,
            "format": request.format,  # NEU!
            "format_fields": format_info.get("fields", [])  # NEU!
        }
        log_stage("5_RESPONSE", stage_5_data)
        field_flow.append({
            "stage": "5_RESPONSE",
            "timestamp": get_timestamp(),
            "data": {"latency_ms": latency_ms}
        })
        
        # ğŸ¨ STAGE 5.5: STYLE ALCHEMY
        alchemized_response = response_text
        style_info = None
        if request.style and STYLE_ALCHEMIST_AVAILABLE:
            alchemized_response, style_info = apply_style_magic(response_text, request.style)
        
        # ğŸ” DEBUG GRIMOIRE
        debug_grimoire = None
        if request.debug:
            debug_grimoire = {"wrapper_chain": wrapper_chain, "format": request.format, "style": request.style, "prompt_len": len(wrapped_prompt)}
        
        # ğŸš€ RETURN
        return ChatResponse(
            response=alchemized_response,
            metadata={"request_id": request_id, "wrapper_chain": wrapper_chain, "format": request.format, "format_fields": format_info.get("fields", []), "style": request.style, "latency_ms": latency_ms},
            field_flow=field_flow,
            debug_info=debug_grimoire,
            style_info=style_info
        )
        
    except Exception as e:
        log_stage("ERROR", {
            "request_id": request_id,
            "error": str(e),
            "error_type": type(e).__name__
        })
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/resonanz/chat", response_model=ChatResponse)
async def resonance_chat(request: ChatRequest):
    """
    ğŸ’¬ RESONANZ CHAT - Alias zu /api/chat
    
    Gleiche FunktionalitÃ¤t, anderer Pfad.
    """
    return await chat(request)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ¥ WRAPPER HEALTH CHECK ENDPOINTS (NEU!)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.get("/resonanz/health/wrappers")
async def wrapper_health():
    """
    ğŸ¥ WRAPPER HEALTH CHECK
    
    Zeigt:
    - Wrapper ohne Meta (orphan_txt)
    - Meta ohne Wrapper (orphan_meta)
    - Broken Format Bindings
    - Ungenutzte Formate
    """
    from .resonance.wrapper_meta import check_health
    return check_health()


@app.post("/resonanz/health/fix")
async def fix_wrapper_health():
    """
    ğŸ”§ AUTO-FIX ORPHANS
    
    - Erstellt .meta.json fÃ¼r Wrapper ohne Meta
    - LÃ¶scht .meta.json ohne Wrapper
    """
    from .resonance.wrapper_meta import auto_fix_orphans
    return auto_fix_orphans()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ”— FORMAT BINDING ENDPOINTS (NEU!)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.get("/resonanz/wrapper/{name}/meta")
async def get_wrapper_meta(name: str):
    """
    ğŸ“– WRAPPER META LADEN
    """
    from .resonance.wrapper_meta import load_meta_or_default, load_stats
    
    wrapper_path = Path(f"/opt/syntx-config/wrappers/{name}.txt")
    if not wrapper_path.exists():
        raise HTTPException(status_code=404, detail=f"Wrapper '{name}' nicht gefunden")
    
    meta = load_meta_or_default(name)
    stats = load_stats(name)
    
    return {
        "status": "success",
        "wrapper": name,
        "meta": meta,
        "stats": stats
    }


@app.put("/resonanz/wrapper/{name}/meta")
async def update_wrapper_meta(name: str, meta_update: dict):
    """
    ğŸ’¾ WRAPPER META UPDATEN
    """
    from .resonance.wrapper_meta import load_meta_or_default, save_meta
    
    wrapper_path = Path(f"/opt/syntx-config/wrappers/{name}.txt")
    if not wrapper_path.exists():
        raise HTTPException(status_code=404, detail=f"Wrapper '{name}' nicht gefunden")
    
    meta = load_meta_or_default(name)
    
    # Update nur die Ã¼bergebenen Felder
    for key, value in meta_update.items():
        if key not in ["created", "updated"]:  # Diese nicht Ã¼berschreiben
            meta[key] = value
    
    meta["auto_generated"] = False
    
    if save_meta(name, meta):
        return {
            "status": "success",
            "message": f"Meta fÃ¼r '{name}' aktualisiert",
            "meta": meta
        }
    else:
        raise HTTPException(status_code=500, detail="Meta konnte nicht gespeichert werden")


@app.put("/resonanz/wrapper/{name}/format")
async def set_wrapper_format(name: str, format_name: Optional[str] = None):
    """
    ğŸ”— FORMAT BINDING SETZEN
    
    Bindet ein Format an einen Wrapper.
    format_name=None oder "" entfernt die Bindung.
    """
    from .resonance.wrapper_meta import set_format_binding
    
    wrapper_path = Path(f"/opt/syntx-config/wrappers/{name}.txt")
    if not wrapper_path.exists():
        raise HTTPException(status_code=404, detail=f"Wrapper '{name}' nicht gefunden")
    
    # PrÃ¼fe ob Format existiert (wenn angegeben)
    if format_name:
        format_path = Path(f"/opt/syntx-config/formats/{format_name}.json")
        if not format_path.exists():
            raise HTTPException(status_code=404, detail=f"Format '{format_name}' nicht gefunden")
    
    if set_format_binding(name, format_name if format_name else None):
        return {
            "status": "success",
            "message": f"Format '{format_name or 'None'}' an Wrapper '{name}' gebunden",
            "wrapper": name,
            "format": format_name
        }
    else:
        raise HTTPException(status_code=500, detail="Format-Binding konnte nicht gespeichert werden")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  ğŸ“Š WRAPPER STATS ENDPOINTS (NEU!)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.get("/resonanz/wrapper/{name}/stats")
async def get_wrapper_stats(name: str):
    """
    ğŸ“Š WRAPPER STATS LADEN
    """
    from .resonance.wrapper_meta import load_stats
    
    stats = load_stats(name)
    return {
        "status": "success",
        "wrapper": name,
        "stats": stats
    }


@app.get("/resonanz/wrappers/full")
async def list_wrappers_full():
    """
    ğŸ” ALLE WRAPPER MIT META + STATS
    """
    from .resonance.wrapper_meta import list_wrappers_with_meta
    from .resonance.config import get_active_wrapper
    
    wrappers = list_wrappers_with_meta()
    active = get_active_wrapper()
    
    # Add is_active flag
    for w in wrappers:
        w["is_active"] = (w["name"] == active)
    
    return {
        "status": "success",
        "count": len(wrappers),
        "active_wrapper": active,
        "wrappers": wrappers
    }
